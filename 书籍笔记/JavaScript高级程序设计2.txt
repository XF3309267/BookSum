1.  面向对象的程序设计 （第六章）
	a. 属性特性
		ECMA-262 第 5 版在定义只有内部才用的特性（默认特性），在JavaScript中不能直接访问		
		为了表示特性是内部值，规范把他们放在方括号中。
		ECMAScript 中有两种属性： 数据属性 和 访问器属性
	    a-1  数据属性
	 	[[Configurable]]: 	
		 	表示 能否通过 delete 删除从而重新定义属性，能否修改属性的				
			特性或者能否把属性修改为访问器属性。一般未修改的情况下为 true。
		[[Enumerable]]: 	
			表示能否使用 for-in 循环返回属性。一般未修改的情况下true
		[[Writeable]]:		
			能否修改属性的值， 默认为 true
		[[Value]]:		
			包含这个属性的数据值。读取时，从该位置读取，写入时也是。默认 undefined
	    a-2  修改属性默认的特性
		方法： Object.defineProjperty() ,接受三个参数：
		属性所在对象  
		属性的名字 
		描述符对象：该对象属性必须是： configurable 、enumerable、writable、value
		例子：
			var person = {};
			Object.defineProperty(person,"name",{
				writable: false,    // 设置为不能更改
				value:  "Nicholas"
			});
			alert(person.name);    	// "Nicholas"
			person.name = "Greg";
			alert(person.name);	//  "Nicholas"
		// 非严格模式下指定新值，会被忽略
		// 严格模式下会导致错误
		例子（接着上面的语句）:
			 Object.defineProperty(person,"name",{
				configurable:	 false,    // 设置为不能删除
				value:  	"Nicholas"
			});
			delete person.name;	//  无效
		// 非严格模式下指定新值，会被忽略
		// 严格模式下会导致错误
		// 一旦把属性定义为不可配置的，就不能再把它变回可配置
		// 就算把再来一次将其  configurable 设置为： "true",也没用
	    a-3  访问器属性  （即由 Object.defineProperty 创建的属性）	
		访问器属性不能直接定义，必须使用  Object.defineProperty() 来定义
		访问器属性不含数据值，它包含一对 getter  和 setter 函数（这两个函数都不是必需的）
				
		访问器属性有 4 个特性：
		[[Configurable]]
		[[Enumerable]]
		[[Get]]: 读取属性时调用函数，  默认值为：undefined
		[[Set]]：写入属性时调用函数。  默认值为：undefined

		1.一般在创建对象属性时，在变量面前加一个下划线，以表示该属性只能通过对象访问的属性
		2.读取属性时调用 getter，写入时调用 setter
		例子：
			var book = {
				_year: 	2004,
				edition:1			
				};
			Object.defineProperty(book,"year",{
				get: function(){
					return this._year;
				// 对于 1 所总结的，表示很不懂，“只能”？访问器中函数也能访问
				},	
				set: function(newvalue){  // set的函数必须是有参数，不然无法写入
					if(newvalue > 2004){
					   this._year = newvalue;
					   this.deition +=newvalue  - 2004;
					}
				}
				});
			book.year = 2005; 
			alert(book.edition);
		3. 对于访问器属性不一定同时指定 getter 和 setter 函数。如果只指定 getter ，就不能
		   写入，尝试写入会被忽略（非严格模式下）、抛出错误（严格模式下）
		   如果只指定 setter 就不能获取，获取会为 undefined
	    a-4  创建访问器属性一般使用两个非标准的方法：
		   	_defineGetter_()  
				book._defineGetter_("year",function(){
					return this_year;
				});
			_defineSetter_()
				book._defineSetter_("year",function(){
					........
				})

	    a-5  定义多个属性
		defineProperties() 方法
		（高三 p142）
	
	    a-5  读取属性的特性
		Object.getOwnPropertyDescriptor() 方法
		接收两个参数： 1.  属性所在对象		2. 要读取其描述符的属性名称
		访问器属性有： configurable、 enumerable、 get 、set
		数据属性有：   configurable、 enumerable、 writeable、value
		例子：
			var book ={};
			Object.defineProperties(book,{
			     _year:{
				value: 2004
				},
			     edition:{
				value: 1
				},
			      year:{
				get:function(){
					return this.year
				},
				set:function(newvalue){
					.......
				}
				}
				

			});
			var descriptor = Object.get OwnPropertyDescriptor(book,"_year"); 
			//  获取的是 数据属性，所以不能访问其没有的属性（如：get  set）
	b. 创建对象
	    b-1   工厂模式
		function create(name,age,job){
			var o = new Object()；
			o.name = name；
			....
			o.sayName = function(){
				alert(this.name);
			}
			retturn o;
			}
		var obj = create("Jack",29,"Software");
	    b-2   构造函数模式
		fucntion Person(name,age,job){  //构造函数首字母大写
				this.name = name；
				.....
				this.sayName = function(){..}
			}
		// 与 工厂模式 比较
		   没有显示创建对象
		   直接将属性和方法赋给  this 对象
		   没有return语句
	  	
		使用构造函数创建实例，必须使用 new 操作符，会经历下面 4 个步骤：
		1）创建一个新对象
		2）将构造函数的作用域赋给新对象（ this 就指向这个新对象）
		3）执行构造函数中的代码（一般是添加属性 和 方法）
		4）返回新对象
		
		 对象都带有 constructor(构造函数)属性，能返回创建该实例的构造函数
		 实例(a)   instanceof  构造函数(b)  （检测 实例a 的构造函数是否 构造函数b）
		
		{
			typeof 检测只会返回：
			"number"、"string"、"boolean"、"object"、  "function"   和 "undefined"。
			
			且typeof检测 引用类型都返回 Object 

			https://www.cnblogs.com/Trr-984688199/p/6180040.html
			//  直接单独使用未声明的变量会报错,而使用 typeof 检测 未声明的变量 会返回  undefined
        		//  
        		//  声明 且未赋值的 变量，可以直接使用 且值为 undefined, 使用 typeof 返回 undefined
        		//
        		//  若变量值为 null ， 变量   >>  null      typeof  变量  >>  null
												}



















		





			
		
		