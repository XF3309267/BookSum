   1.  标签的位置
	A.  通常外部文件的引用都放在 </body>标签前面，避免在加载脚本文件时 界面一片空白
	B.  为 <script> 标签定义 defer 属性， 告诉浏览器先下载后执行. 
	     defer 属性只适用于外部脚本文件，在  HTML5  中会忽略 嵌入式脚本 设置的defer属性，
	     IE4 至 IE7 还支持嵌入脚本的的defer属性（仍然放置文本底部）
	C.  为... 定义  async，与  defer  类似，只适用于外部文件， 并告诉浏览器立即下载文件，
		但并不按照顺序执行，所以两者之间的 互不依赖 非常重要。           
		 async 属性目的是不让页面等待脚本的下载和执行 从而异加载内容。
		异步脚本 在 load 事件前执行，但可能在  DOMContentLoaded 事件触发之前或之后执行。
2.  object 类型
	A.  创建 object 实例方法
		1.   var obj = new Object();  		 Object  构造函数 
		2.   var obj = { name:"Jack",age: 29};	对象字面量，在于 简化创建大量属性的对象的过程
		      age  是该对象的最后一个属性，其后不能加 逗号（在IE7 更早版本和 Opera会出现错误）
		3.  var obj = { 5：true };  	属性名 5 会自动转化为 字符串。
		4.   在函数许多个参数时， 可：  
			function example（args）{
				if(typeof   args.name == "string"){.......}  检测属性是否存在
				if(typeof  args.age == "number"){......}			
			}
		5.  方括号表示法 与  点表示法
			方括号表示法的优势：
				1.  可以通过变量来访问属性：
					var  na = "name";
					alert(person[na]);   "Jack"
				2.  如果属性名中包含语法错误的字符 或 使用的是关键字 、 保留字，可				     
					使用方括号表示法：
					person["first name"] = "Bob";

			通常 除非必须使用变量来访问属性，否则建议使用点表示法
	B.  引用类型
		1. 当一个变量向另外一个变量复制引用类型的值时，会复制一份指针给新的变量，而该指针 指向堆中的一个对象。
		   两个变量 引用同一个对象，所以改变其中一个变量另外一个变量也跟着变化。
		2. 函数传参也和变量复制是一样的（对于 值变量 和 引用变量），而参数只能按值传递（引用类型的值就是 所指向对象的指针）
		   在函数内部改变引用类型的值，外部对象也会跟着改变。
		3. 根据上述，有特殊情况：
			如： function setName（obj）{
				obj.name = "Jack";
				obj = new Object(); //  ********
				obj.name = "Bob";   //  ********
			}
			     var  person = new Object();
			     setName(person);
			     alert(person.name);
			解释：若没有 * 那两句， 结果为： Jack
			      第一句: 为 obj 重新定义了一个对象
			      第二句：为 obj 定义了一个name属性，且值为： Bob 
			      在函数内部重写了 obj ，这个变量引用的就是一个局部对象了。局部对象函数结束后立即销毁


3.  Array 类型
	A.  创建数组
		1.  Array 构造函数:  
			               var  colors = new Array();  、 var colors = new  Array(3);   、  
			               var  names = new Array("Jack");  包含一项的数组
 				也可省略   new 
		2.  数组字面量：
			var   colors  =  ["bule","red"];
			var  values = [1,2,];   在IE8之前的版本会认为是一个有 3 项的数组，而在其他浏览器会认为是 2 项
			var  options = [ , , , , , ];   ....之前可能会认为是  有 6项的数组，其他  5 项
		3. 数组的 length ，可以修改 。 如： colors.length  = 4;  长度增大则，为 undefined。 
			若   colors[colors.length] = "black"; 则会增加数组从长度。
			若   colors[999] = "blue" ;   会增加数组长度，但没有明确数组项的值为   undefined
			数组最多存 2 294 967 295 个项。若数组初始大小与这个上限值接近，可能会导致运行时间超长的脚本错误

		（*******以下之后要补充） 
		4. 检测数组
		       书中原文： 
			    instanceof   的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，
			那实际上就存在两个不同的全局执行环境，从而存在两个不同版本的 Array  构造函数。
			如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中
			原生创建的数组分别具有各自的不同构造函数。

		       新增   Array.isArray( value )    最终确定 某个值（即：value） 是不是  数组
	B.  转换方法
		toLocaleString() 	toString()		valueOf()
				
		alert(Array); 	因 alert 要接受字符串参数，所以会在后台调用  toString 或 toLocaleString 方法
		toString() 	将数组以 逗号 分隔拼接成一个 字符串 
		
		valueOf() 		valueOf() 方法返回 Array 对象的原始值。
				该原始值由 Array 对象派生的所有对象继承。
				valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。
		toLocaleString(原文)
			       该方法 返回与 toString() 、valueOf()  方法相同的值，但也不总是如此。
			 当调用 toLocaleString() 方法时，他也会创建一个数组值以逗号分隔的字符串。
			 而与前两个方法不同之处在于，为了取得每一项的值，调用的是每一项的  toLocaleString()方法，
			 而不是  toString() 方法。 （高三  P89）
	********	join() 方法，则可以使用不同的分隔符来构建这个字符串，只接受一个参数，即作为分隔符的字符串，然后返回字符串
		如： colors.join("||")	    red||blue||green.
		不传值 或 传入 undefined，则使用逗号作为分隔符。在  IE7 及跟早版本会以  "undefined" 作为分隔符
	***（如果数组某一项的值是 null 或 undefined，在其上方法会以空字符串表示）
	C.  栈方法  和 队列方法
		栈： 最新添加的项最早被移除，后进先出。尾加尾删
			Array.push(value);   		从数组末尾加入元素，返回数组的长度
			Array.pop();		删除数组末尾的一项元素，返回删除的项
		队列: 队列末端添加项，列表前端移除项，尾加 头删
			Array.shift();	移除数组第一项并返回该项
			（  Array.unshift(value);   添加元素至数组头部   ）
	D.  数组重排序
		Array.reverse();		数组反转
		Array.sort();		数组排序（默认从小到大排序）
		   	 sort 	可以接收一个比较函数作为参数，比较函数接收 两个参数
		如果第一个参数应该位于第二个参数之前就返回一个负数；  ( 之前  即指 索引靠前 （小） )
		       两参数相等，返回0.
		       第一个参数应该位于第二个参数之后就返回一个正数
		 
		如：function compare( p1, p2 ){ 	//  想要从小到大排序
			if( p1 < p2 ){
			       return   -1;
			}else  if (p1 >) {
			       return    1;
			}
		}
		简化：  function   compare (  p1 , p2 ){
			//   负数    >>>  确定原先数组元素位置 
			//   正数    >>>  交换元素位置
	
			return  p1- p2;      
			//  p2   大于   p1  时确定位置 
			//  p2   小于   p1  时交换位置 
			}
	E. 数组操作方法:  contact()   、 slice() 、  splice() 
	     contact ( ) 方法	基于  某个数组的所有项  创建一个新的数组。
		colors.contact( value );   可加参数（可加多个，以逗号隔开），即在原来数组的基础上在数组末尾加上这些 元素。
		若 value 中 含有数组，则将数组中的每一项 一一加入到 复制的数组后面。
	     slice( ) 方法	基于某个数组的一项 或者  多项来创建数组
		slice( ) ，方法可以   没有参数、一个参数、两个参数

		 无参     	   >> 	则只是简单的复制一份，后返回。
		一个参数 	   >>	截取  该参数到数组末尾的一段
		两个参数	   >>        colors.slice( a , b);    a:  所要截取数组的开始端， 
				b：所要截取数组末端 （且不包括），返回所截取的数组。
		若 slice  方法中含有 负数，则加上数组的长度。
		若  初始位置  大于  结束位置，则 返回空数组 
	       splice()  方法
		删除： colors.splice(0,2)   要删除 第一项的位置    和  要删除的个数，返回删除项
		插入：需要三个参数， 1 > 起始位置； 2 > 删除个数；  3  > 插入的值，可多个以逗号隔开
		替换： 删除后 再 插入  ==   替换		

	F.  位置方法    >>    	查找数组元素的位置
		indexOf( )   、 lastIndexOf() 
			均可有俩个参数： 要查找的项   和  （可选）查找起点，
			均返回元素在数组中的位置（即索引）
			这两方法 与数组中的每一项比较时，会使用 全等操作符，必须严格相等。
		lastIndexOf () , 从起点位置往前找、或数组末尾往前找

		例子：	(只讲一些特殊的例子)
			var  num = [1,2,3,4,5,4,3,2,1];
			num.indexOf( 4，4 )；    //  5    （以  5  这个元素 开始向后找 4，即会找较后面的    4）
			num.lastIndexOf(4，4);   //  3	   (以  5  这个元素开始向前找 4 ，即会找到较前面的 4 )
	G.  迭代方法
		ECMAScript  为数组定义了  5 个迭代的方法，	
		    每个方法接收两个参数：  1.   要在每一项上运行的函数，该函数含有三个参数， 数组项的值、 该项在数组中的位置、 数组对象本身
				          2. ( 可选 )运行该函数的作用域对象 — 影响 this 的值。
		every( );  		对每一项运行函数，函数对每一项返回 true，则该函数整体返回 true
		filter( );		对。。。函数，返回该函数会返回 true 的项组成的数组
		forEach( );		对。。。函数，没有返回值
		map( );		对。。。函数，以函数每次返回的结果 组成的数组  作为 返回结果
		some( );   		对。。。函数，只要有一项返回 true， 则该函数返回 true 。
		（详解见：高三  p96 ）
	H.  归并方法
		reduce( );   和   reduceRight( );
		reduce( )  从数组的第一项开始，逐个遍历； 而   reduceRight( )， 从数组最后一项开始，逐个遍历
	      *******     该函数的返回值 会返回给下一项的 第一个参数，直至没有下一项 后 返回最终结果。
		两个函数  接受两个参数：  
		1. 每一项所要调用的函数，该函数接受  4 个参数   >> 前一个值、当前值、项的索引 、数组对象
		2.  （可选）作为归并基础的初始值
		
		如： 	返回数组元素总和 
			var  values = [1,2,3,4,5];
			var  sum = values.reduce( function( prev, cur, index, array){
				retrun  prev+cur;
			})
	3-1.  Date 类型
		1.  Date 类型保存的时间精准到 1970年 1月 1号 前后 1亿天
		2.  创建 Date 类型对象：  var tim = new Date();   必须传入相距 1970/01/01/24:00 的毫秒数，当然也可传入其他格式的字符串。
		3.  Date.parse（）接收一个表示日期的字符串，返回相应的秒数，ECMA-262 没有定义该方法应该支持哪种日期格式，通常因地区而异。
		    而在创建 Date 对象时，也接收 这样的字符串。如：var someDate = new  
	

4 .  数据类型
	A.  5 种基本数据类型： Undefined 、Null、Boolean、 Number 、 String  。  object  （复杂数据类型）
	B.  typeof  操作符可以返回下列字符串： undefined、boolean、string、number、object、function
	     对于已声明且为初始化的 变量 ，  typeof  变量名  = “undefined”
	     且 对于 为声明的变量	       typeof  变量名  =   “undefined”  
	boolean  类型
	Number类型  转  boolean类型： 0 和 NaN >>> false, 其余  都为 true
	object   类型  转  boolean类型：   null   >>> false,  其余为  true
	undefined		              ：  只有  false

5. number 类型
	A.  过大的数字用   e 表示法（科学计数法）
	B.   0.1 + 0.2   不等于  0.3 （浮点计算的通病） ；    0.15 + 0.15 = 0.3	
	C.   数字范围： 
		能够表示的最小数值：   Number.MIN_VALUE     =  5e-324;(显然对于的是 精度 )
		最大的数值             ：   Number.MAX_VALUE    =   1.797691348623157e+308
		如果在 js 脚本计算中超出两者的精度范围：就会转化成   Infinty（正数）， -Infinty （负数）
	D.  NaN  :  表示要返回数值的情况下未返回数值，（未返回数值  就会返回  NaN）
		NaN  与任何数值  计算 结果都是  NaN
		isNaN(  value );   判断 value  是否是  NaN，是返回  true；
	E.  数值转化
	         字符串 转化为  数值
		Number( value );    转化为数值 。 value ：  字符串
		parseInt( value, level );
		level:  进制。  
		如： parseInt( "10",8 )  > (把 "10" 以 8 进制为基地  转化为  10 进制) ，结果为： 8
		且在没有第二个参数的时候，会自动以十进制为基地进行转换。
		如果 level 为 16，则字符串中的  0X 可以省略（一个坑）		

	          两者在解析字符串的时候，如果字符串的第一个字符 不是数字字符 也不是  负号，
		Number  parseInt 会将其转化为 NaN，且在第一个是空格的情况下，
		Number 转化为 0  ；   parseInt  转化为  NaN
		
	          parseFloat(value )
		该方法没有 第二个参数， 只以十进制进行转换，且自动省略前面的 0，
		解析字符串会一直解析到  第二个小数点 或者  字符串末尾
6.  String
	String 类型用来表示     由 0 个或 多个 16位 Unicode 字符 组成的 字符串序列
	A.  特殊字符字面量（也叫 转义序列）
		 如： \xnn   、以 16进制代码 表示   一个字符，（\x41） 表示 ‘A’
		        \unnnn  以 16进制代码 表示   一个 Unicode 字符	
	B.  length 属性
		如果字符串中含有  转义字符 也算进    length  里，
		如果字符串中含有   双字节字符 ，  length  的精准度会有问题

	C.  数值的 value.toString ( level)   方法，
		对于 Null   和  Undefined  没有该方法
		level ：  将 value 以十进制为基地  转化为  level 进制的数

	         String(value） 会自动调用  toString ()  方法，
		String(null)  = "null";
		String(undefined) = undefined";
	D.  字符串 转换为  布尔值
		字符串非空  转化为   true,其余为  true


	
7.  操作符  （用以操作数据值）有： 算术操作符、位操作符、关系操作符、等号操作符
	A.   x += x；    x=+x；
	B.   object() 类型的数值   转换为其他的  类型时，一般操作： (1) 调用对象的  valueOf()，取得一个可操作的值，然后对其执行向其他操作。
	      如果上述 (1) 操作返回的是  NaN ，则执行   (2) 对对象调用 toString() 方法，在如 对一般类型的值一样进行 相应许需要的转换
	C.  位操作符
		按 内存中表示数据 的 位 来操作数据。
	         1. ECMAScript  中的所有数值都以  IEEE-754  64 位格式存储，先将 64位的值转化位 32 整数，然后对其操作，最后又转化为  64位
                         2.  第 32 位 表示 符号位，其余几位 用以表示数值。若没有满足 32 位  ，则在有效数字之前  且在符号位之后， 添  数字  0；
	         3.  负数 是以 二进制补码的形式进行存储的
		补码： 原码 （负数的原码  即 绝对值的原码 前 加一个负号 ，如：-5 = -101； 其中 剩余位数，自行 脑补）
		           在原码的基础上除符号位以外   进行反码（0 变 1， 1 变 0），后加  1

	         4. 按位非 （  波浪线 表示： ~ ）
		将其二进码 取反码（且记住： 是数据  以 内存中位的表示法，来执行这些操作）   
		::: >>>>   负数的二进码存储形式是  原码的补码
		var  num      =   25；
		var  num2    =   ~ num；   //  num2 = -26 
		按位非    =   原来的值   取其负值   后 减一   ；（可根据上述例子）

	         5.  按位与   （ & ）
		两者二进码进行 各位数进行 比较， 都为 1 则是 1；
		25 = 00000  00  00 0       0001  1001
		3   = 00000  00  00 0       0000  0011；
		所以两者 执行 按位与  00000  00  00 0       0000  0001 ，结果为 1；
	         6.  按位或  （ | ）  
		两者 二进制码 进行比较 ，有  1 则 1；
	         7.  按位异或  (  ^ ） 
		……   		， 有 一个 1 才是 1；

	         8.  按位或    与   按位异或  比较，相同的数值比较，不同的 按位操作符。
		前者的结果 的绝对值一定比后者的结果的绝对值大（可自行理解）

	         9 .  左移    （符号： <<   ） 指的是  有符号左移
		   将数值位全体向左移，后面 补  0； 左移  n  位 ==  该数值（原十进制数） 乘以   2的 n 次方
	         10.   右移    （符号： >>  ）  有符号右移
		   将数值位全体向右移，右边以 符号位 来填充
		无符号右移  （符号  >>>  ）
		    对于正负数一样，都会忽略   符号位 ，都将其 二进制码 看成是 正数的码。
	 	    所以，在对 负数执行  无符号右移时，会出错。
		    因为负数的二进码（原码的补码），看成 正数的 二进码会 非常大，然后进行 向右移，结果依然是错的。
	
	D. 布尔操作符
		
		逻辑非（ ！）、逻辑与（ && ）、逻辑或 （ || ）
		object  数值  在  布尔操作符中  会被认为是  true
           	         逻辑与： A  &&  B                能拖延返回就拖延返回
		若   A  为对象，则返回  B，
		若   B   为对象，且在  A 转换为布尔值时 是 true 的情况下，返回  B
		若   A  与 B 皆对象，则返回  B
	    	逻辑与中不能出现   未定义的变量， 不然会发生错误
	        逻辑或：  A  ||  B 	能返回  就 返回
		如果第一个操作数能返回则返回，不会再理会 第二个操作数，所以如果第二个操作数 是 未声明的变量
		若要在 逻辑或中 返回  null  undefined   NaN ，则要两个参数都是 unll    undefined   NaN
	E.  乘性操作符：  乘法、 除法、求模
		乘法：	
			1.  如果乘法中含有  NaN  则，这一系列的计算结果  就是  NaN
			2.  Infinity  与  0  相乘  ，结果为   NaN
			3.  Infinity   与  除 0 以外的数字相乘，结果 为  Infinity  或  -Infinity
		除法：（\）
			1.    即  数值 和 Infinity  被 0 除 ，结果为  Infinity  或  -Infinity
			2.    0  被 0 除，结果为 NaN；    Infinity  被  Infinity 除 结果为  NaN
			3.    0 被 任何 非0 除，结果都为  0；
			4.    Infinity  可以是  无限大，所以  Infinity 除以 任何数值（除了  0 和 Infinity系列），任然为  Infinity	
			       Infinity   作为 除数，被除数 为任何值（ 除了  0 和 Infinity系列），结果都为 0；
		求模（又称： 取余  %）
			1.   分子   为  Infinity  结果都为  NaN；  包括 分子  分母 都为 Infinity 的情况
			2.   分母  为    0       结果为  NaN
			3.   分子为  0  结果  都为 0； （且 排除  2  的情况）	
			4.   分母   为  Infinity ，分子 不为 Infinity 和 0，结果都为 分子。
	F.  加性操作符：加法操作符   和  减法操作符
	       共有： 在有  Infinity  和  -Infinity（当然 减去  Infinity 也是）  的情况下，结果为  NaN
		  在需要涉及到将  null  或  undefined 转化为数值时，  null 和  undefined  都转换为   0；
		  在 谷歌浏览器中 ，对 未声明的变量进行操作会报错
		加法：
			1.  （+0）+ （+0） = +0；
			2.  （-0） +  （-0） =  -0；
			3.  （+0） + （-0） =  +0；
			与普通的 正负数算法一样
		注意：  一般算术是从左往右，所以在有字符串的情况下 
			var   num = “a”+ 3+4；//    “a34”
			从左往右，会进行字符串拼接，所以  a 将 3 拼接成字符串，后又将 4 拼接成字符串。
		减法：
	G.  关系操作符：  <  、 > 、<= 、  >= 、
		1.  含有数值 进行比较，且都需转化为 数值进行比较，且从左往右。
		      所以，注意多个  关系操作符的出现
		2.  字符串之间的比较 ，比较两个字符串之间的字符编码值
		3.  含有  对象对类型，则需要使用  valueOf()  或  toString() 方法进行转换，相应的需要。（即看另外一个比较数）
		     如果两个都是对象类型（有待考究）
		4.  在  字符串 与 未初始化的变量进行比较时，返回的 都是  false	
		5.  与  NaN  的一系列操作都是   false
		6.  boolean  值 都会先转换为   1 或 0 ，再继续进行比较。（在算数计算中也是如此）
		
	H.  相等操作符：   相等： ==   、  !=  、     全等 ：===  、 !==
		1.  unll  与 undefined  相等， 不全等
		2.  NaN  与  NaN  不相等，更不全等
		3.  与 NaN 的一系列操作都为 false
		4.  全等 必须 一模一样，类型  、数值
		5.  undefined  和   null   都不等于  0
		6.  对象 与 对象，必须指向同一个内存  或 是被另外一个对象所赋值的

	I.  条件操作符：  三目运算符	
	J.  赋值操作符： 一系列就不说了，如：  /= 、 %= 、 >>= 、<<=（左移赋值） 、>>>= 、（无符号右移）
	K.  逗号操作符：  在一些基本分隔除外，逗号还有一些功能。
		           var  num  = 12，3，4，5；  //  会将最后一个值 赋给  num 		
	L.  label  语句 
	 	如：  start: for(var i =0; i<13;<i++){
			for(var j  =0 ; j<10 ; j++）{
			if(i==2 &&  j==3){
				break  start;  // 对外层 对于使用了 start 标记的 循环进行  停止；  （while  一样受用）
			}}		
			};
		start  用以标记该  for 循环，好在内层循环中可以  使用 continue  或  break  对该循环操作
	M.  with 语句  
		with（obj）{
		var a = href；
		//   with 里面的变量，首先会在 所在的局部环境中找，若没有则会 在  obj 对象中找
		}
		var  a = obj.href;   //  与上述意思一样，且是在满足上述情况下
	N.  switch  语句
		case： 25:
		case： 35:  alert（”25 和 35“）；break；  // 合并
		js  中 switch 语句与 普通编程语言的 不同：
		1.  switch（expression ） ； expression  可以是任何 类型的值 (字符串  、 对象 )
		2.  case： value ； 	   value 可以是变量， 也可以是表达式
		3.   例子：
			var num =1 ；
			switch（true）{
			case： num > 1；
			           alert（）；	
			           break；		
			default：
				alert（）；
			}
		4.  只要有满足   expression 的  case (当然有break，满足条件就会结束)  就行 （ 高三   p61 ）
	O.   函数参数
		1.  ECMAScript 中的参数 在内部用一个数组来表示，函数内部使用  arguments  对象来访问这个数组。例如： arguments[0]=第一个参数，以此类推
		2.  一般条件下  函数预备需要多少个参数，最多传入与之相等数量的实参进来。
		3.  arguments 数组元素 是 参数是同步的，即两者的值是联通的，虽然它们不是指向同一个内存。
		    前提是  arguments 数组中调用的数组元素时，函数调用时 传入进来了与 数组元素 对应的实参。
		4.  arguments 数组的长度由参数（传入的实参）所决定，
				（在形参数量大于实参数量的条件下）  没有传递值的命名参数将自动赋予 undefined （使用 arguments 改变值没用）
		5.  在严格模式下，不能修改 arguments 中的值，也不能与 参数 相联通

8.  作用域 与 内存 
	A.  检测类型
		1.  检测基本类型使用  typeof 操作符，可检测基本数据类型，typeof 检测对象 只会返回 object
		2.  在检测引用类型对象时，instanceof  用以检测 它是什么类型的对象（有  Array 类型的对象、RegExp类型的对象）
			如：（ persons  instanceof Array ），如果用instanceof检测除 object以为的值或变量，会返回 false
		3.  所有引用类型的值都是  object 的实例，包括 Object构造函数
		4.  在ECMA-262规定任何内部使用 [call]方法的对象，使用 instanceof 检测该对象都会返回 function。
		    因为正则表达式用了 [call] 方法，所以在  Safari5及之前版本 和 Chrome7及之前版本 使用 typeof 检测 正则返回 function
		    而在  IE 和 Firefox  使用 typeof 检测正则 返回 Object
	B.  执行环境 与 作用域
		执行环境： 执行环境定义了变量 或 函数有权访问的其他数据
		1.  每个执行环境都有一个与之相关联的 变量对象， 环境中定义的所有变量 和 函数 都保存在这个对象中
		2.  某个执行环境中的代码执行完毕后，该环境被销毁，保存其中的变量 和 函数定义 也被销毁。（全局 会在关闭网页 或 浏览器 时销毁）
		3.  每个函数都有自己的执行环境，执行时，压入 环境栈，执行完毕后 弹出 环境栈，把控制权返回给 之前的执行环境。
		4.  当代码在执行时，会创建变量对象的一个作用域链。作用域链：保证对执行环境的数据的有序访问。 
 		5.  作用域链中包含与之相关联的所有执行环境，在寻找变量 或 函数 时，会一级一级往上找。

	C.  延长作用域链
		有些语句可以在作用域链前端临时增加一个变量对象，在此举例： try-catch   、 with
		1.  with  会将指定对象添加到作用域链中
		2.  catch 语句会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
		3.  在函数中的 with 语句， with 语句所定义的变量，会成为执行环境的一部分，所以可以用于函数当中。
		4.  高三 P75，关于 catch语句所捕捉得错误对象，会被添加到  执行环境的变量对象，而不是 catch 的语句的变量对象中，在 catch 外部也可以
		    访问 该对象（仅仅在 IE8版本 之前）
	D.  没有块级作用域
		1.  在其他编程语言中 像for 、while、if 之类的，由花括号封闭的代码块都有自己的作用域（执行环境）
		    在 这些其中的所定义的变量，会在代码块结束后销毁，而 JS 不会，他会将这些变量 添加到当前的执行环境中。
	E.  变量声明
		1.  声明变量会添加到最近的执行环境中，没有使用 var 或 其他声明的 变量 会被定义为 全局变量。
		2.  要想在 函数中使用 全局变量，且该 全局变量的名字 在函数有定义。但又想在该函数中使用全局变量，可以使用 window.value（value 变量名）


































